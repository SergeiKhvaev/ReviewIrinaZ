package day21Loop;

public class biggestStringOfMatchingChar {

    // найти наибольшую подстраку с повторяющимися вподряд одинаковых символов
    public static void main(String[] args) {

        String str = "aaabbbccccdddddeeeeeeeee";// если последняя сабстрока самая длинняя то
        String longest = "";
        String each = "";
        for (int i = 0; i < str.length() -1; i++) {// внимание при таком условии i < str.length() -1 никогда не проверится последний символ встроке, т.к. при < и -1 (-1 нам нужна, т.к. ниже есть +1) -> что бы избежать outOfBounce делаем -1( что бы оставновить проверку несуществующего индекса кода код проверяет i +1 индекс), так вот длинна строки получается -1, т.е останвиливается проверка на предпоследнем символе (полседний в проверку не входит, а он может быть решающим)
            each += str.charAt(i); //aaaa (проходит первых 4 цикла и т.к. первые 4 являются а, то перед пятым циклом each = "aaaa"
            // каждый символ мы помещаем в эту строку и первый цикл положил туда символ 'а' в случае, если нижистоящие IF не впускают в себя, строка each дополняется одним символом при каждом цикле, таким образом, что нижестоящие IF не срабатывают, это означает, что при каждом цикле к строке добавляются идентичные символы. При начале циклов, проверяющих первые буквы подстрок, начинающихся с новых символов эта строка снова пустая, т.к. код ее обнулил

            if (i == str.length() -2 && str.charAt(i) == str.charAt(i + 1)) { // этот if ключается когда подстрока нужно проверить последний символ является ли он идентичным символам в последней из проверенной подствроки. Это нужно потому, что по условиям   for loop i < str.length()-1 -> последний символ не проверяется, код останавливает проверку на предпоследнем символе, таким образом, пишем отдельный if, по которому если i == предпоследнему символу в строке и этот равен последнему символу строки, то отдельно проверяется длинна этой подстроки с самой длинной строкой на этот момент
                each+= str.charAt(i+1);
                if (each.length() > longest.length()) { // проверяем подствроку с последними символами изначальной строки(включая последний символ строки) на длинну с самой длинной подстрокой на этот момент
                    longest = each; // определили новую длинную строку
                }

            }
            if(str.charAt(i) != str.charAt(i+1)) { // если при очередном цикле код выявляет, что следующий символ не тождественнен предыдущему, если такой символ обнаруживается
                if(each.length() > longest.length()){ // на пятый цикл, т.е. когда проверяется первая b получается что первый each(aaaa) является длиннее longest т.к. longest изначально равен пустой строке
                    longest = each; // на пятый цикл, когда проверяется первая b  код присваевает переменной longest значение первой первой самой длинной each, в этом случае each = "aaaa" --> longest == each --> longest == "aaaa"
                }
                each = ""; // обнуляем each, т.к. пока она все еще хранит "aaaa", обнуляем, что бы была возможность ее использовать при проверки строки, которая начинается с буквы b

            }
        }
        System.out.println(longest);

    }
}
